package ctrlflow

import (
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"testing"

	"golang.org/x/tools/go/ssa"
	"golang.org/x/tools/go/ssa/ssautil"
)

func buildSSA(t *testing.T, src string) (*ssa.Package, *ast.File) {
	t.Helper()
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", src, parser.ParseComments)
	if err != nil {
		t.Fatalf("parse failed: %v", err)
	}
	pkg := types.NewPackage("p", "p")
	ssaPkg, _, err := ssautil.BuildPackage(&types.Config{Importer: importer.Default()}, fset, pkg, []*ast.File{file}, 0)
	if err != nil {
		t.Fatalf("ssa build failed: %v", err)
	}
	return ssaPkg, file
}

func TestHasGoDirective(t *testing.T) {
	cases := []struct {
		name string
		doc  *ast.CommentGroup
		want bool
	}{
		{"nil", nil, false},
		{"non-go", &ast.CommentGroup{List: []*ast.Comment{{Text: "//garble:controlflow"}}}, false},
		{"go-linkname", &ast.CommentGroup{List: []*ast.Comment{{Text: "//go:linkname x y"}}}, true},
		{"go-noinline", &ast.CommentGroup{List: []*ast.Comment{{Text: "//go:noinline"}}}, true},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			if got := hasGoDirective(tc.doc); got != tc.want {
				t.Fatalf("hasGoDirective=%v, want %v", got, tc.want)
			}
		})
	}
}

func TestIsCgoGeneratedFile(t *testing.T) {
	fset := token.NewFileSet()

	fileByName := func(name string) *ast.File {
		f := fset.AddFile(name, -1, 100)
		return &ast.File{Name: ast.NewIdent("p"), Package: f.Pos(1)}
	}

	if !isCgoGeneratedFile(fset, fileByName("_cgo_gotypes.go")) {
		t.Fatal("expected _cgo_ filename to be treated as cgo-generated")
	}
	if !isCgoGeneratedFile(fset, fileByName("wrap.cgo1.go")) {
		t.Fatal("expected .cgo1.go filename to be treated as cgo-generated")
	}

	file := fileByName("regular.go")
	file.Comments = []*ast.CommentGroup{{
		List: []*ast.Comment{{Text: "// Code generated by cmd/cgo; DO NOT EDIT."}},
	}}
	if !isCgoGeneratedFile(fset, file) {
		t.Fatal("expected cgo comment to be treated as cgo-generated")
	}

	plain := fileByName("plain.go")
	if isCgoGeneratedFile(fset, plain) {
		t.Fatal("did not expect plain file to be treated as cgo-generated")
	}
}

func TestHasPredeclaredNames(t *testing.T) {
	ssaPkg, _ := buildSSA(t, `package p

func ok(x int) {}
func badParam(int int) {}
func badResult() (error error) { return nil }
`)

	if hasPredeclaredNames(ssaPkg.Func("ok")) {
		t.Fatal("ok should not have predeclared names")
	}
	if !hasPredeclaredNames(ssaPkg.Func("badParam")) {
		t.Fatal("badParam should have predeclared names")
	}
	if !hasPredeclaredNames(ssaPkg.Func("badResult")) {
		t.Fatal("badResult should have predeclared names")
	}
}

func TestHasBoundMethodClosure(t *testing.T) {
	ssaPkg, _ := buildSSA(t, `package p

type T struct{}
func (t T) M() {}

func f() {
	var t T
	_ = t.M
}

func g() {
	_ = func() {}
}
`)

	if !hasBoundMethodClosure(ssaPkg.Func("f")) {
		t.Fatal("expected bound method closure to be detected")
	}
	if hasBoundMethodClosure(ssaPkg.Func("g")) {
		t.Fatal("did not expect bound method closure in g")
	}
}
