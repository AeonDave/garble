From a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0 Mon Sep 17 00:00:00 2001
From: Dave <nova.davide@gmail.com>
Date: Mon, 6 Oct 2025 20:15:00 +0200
Subject: [PATCH 3/3] add Feistel encryption for entryOff

---
 cmd/link/internal/ld/pcln.go | 83 ++++++++++++++++++++++++++++++++++--
 1 file changed, 79 insertions(+), 4 deletions(-)

diff --git a/cmd/link/internal/ld/pcln.go b/cmd/link/internal/ld/pcln.go
index b497573b15..a69a928929 100644
--- a/cmd/link/internal/ld/pcln.go
+++ b/cmd/link/internal/ld/pcln.go
@@ -4,25 +4,23 @@
 
 package ld
 
-import (
-	"os"
-)
-
-import (
-	"unicode"
-)
-
 import (
 	"cmd/internal/goobj"
 	"cmd/internal/objabi"
 	"cmd/internal/sys"
 	"cmd/link/internal/loader"
 	"cmd/link/internal/sym"
+	"crypto/sha256"
+	"encoding/base64"
+	"encoding/binary"
 	"fmt"
 	"internal/abi"
 	"internal/buildcfg"
+	"math/bits"
+	"os"
 	"path/filepath"
 	"strings"
+	"unicode"
 )
 
 const funcSize = 11 * 4 // funcSize is the size of the _func object in runtime/runtime2.go
@@ -728,6 +726,22 @@ func writeFuncs(ctxt *Link, sb *loader.SymbolBuilder, funcs []loader.Sym, inlSym
 	var pcsp, pcfile, pcline, pcinline loader.Sym
 	var pcdata []loader.Sym
 
+	// Retrieve and validate the Feistel seed from environment
+	linkSeedBase64 := os.Getenv("LINK_SEED")
+	if linkSeedBase64 == "" {
+		panic("linker: LINK_SEED environment variable must be set for runtime metadata encryption")
+	}
+	seedBytes, err := base64.StdEncoding.DecodeString(linkSeedBase64)
+	if err != nil {
+		panic(fmt.Sprintf("linker: failed to decode LINK_SEED: %v", err))
+	}
+	if len(seedBytes) != 32 {
+		panic(fmt.Sprintf("linker: LINK_SEED must be 32 bytes, got %d", len(seedBytes)))
+	}
+	var seedArray [32]byte
+	copy(seedArray[:], seedBytes)
+	keys := deriveFeistelKeys(seedArray)
+
 	// Write the individual func objects (runtime._func struct).
 	for i, s := range funcs {
 		startLine := int32(0)
@@ -841,6 +855,20 @@ func writeFuncs(ctxt *Link, sb *loader.SymbolBuilder, funcs []loader.Sym, inlSym
 			sb.SetUint32(ctxt.Arch, dataoff, uint32(ldr.SymValue(fdsym)-gofuncBase))
 		}
 	}
+	// Apply Feistel encryption to all entryOff values
+	// Skip sentinel values (^uint32(0)) used for special function entries
+	linkData := sb.Data()
+	for _, off := range startLocations {
+		entryOff := ctxt.Arch.ByteOrder.Uint32(linkData[off:])
+		// Skip encryption for sentinel values
+		if entryOff == ^uint32(0) {
+			continue
+		}
+		// Use nameOff as tweak for format-preserving encryption
+		nameOff := ctxt.Arch.ByteOrder.Uint32(linkData[off+4:])
+		encrypted := feistelEncrypt(entryOff, nameOff, keys)
+		sb.SetUint32(ctxt.Arch, int64(off), encrypted)
+	}
 }
 
 // pclntab initializes the pclntab symbol with
@@ -916,6 +944,43 @@ const (
 	NOIDX         = 0x7fffffff
 )
 
+// Feistel cipher constants and implementation
+const feistelRounds = 4
+
+// deriveFeistelKeys generates round keys from the seed
+func deriveFeistelKeys(seed [32]byte) [feistelRounds]uint32 {
+	var keys [feistelRounds]uint32
+	for i := 0; i < feistelRounds; i++ {
+		h := sha256.New()
+		h.Write(seed[:])
+		h.Write([]byte{byte(i)})
+		sum := h.Sum(nil)
+		keys[i] = binary.LittleEndian.Uint32(sum[:4])
+	}
+	return keys
+}
+
+// feistelEncrypt performs format-preserving encryption on a 32-bit value
+// using a 4-round Feistel network with tweak support
+func feistelEncrypt(value, tweak uint32, keys [feistelRounds]uint32) uint32 {
+	left := uint16(value >> 16)
+	right := uint16(value)
+	for round := 0; round < feistelRounds; round++ {
+		f := feistelRound(right, tweak, keys[round])
+		left, right = right, left^f
+	}
+	return (uint32(left) << 16) | uint32(right)
+}
+
+// feistelRound computes the round function: F(R, tweak, key)
+func feistelRound(right uint16, tweak uint32, key uint32) uint16 {
+	x := uint32(right) ^ tweak ^ key
+	x = x*0x9e3779b1 + 0x7f4a7c15
+	x = bits.RotateLeft32(x, int((key>>27)|1))
+	x ^= x >> 16
+	return uint16(x ^ (key >> 16))
+}
+
 // findfunctab generates a lookup table to quickly find the containing
 // function for a pc. See src/runtime/symtab.go:findfunc for details.
 func (ctxt *Link) findfunctab(state *pclntab, container loader.Bitmap) {
 	// The last element of the functab serves as a sentinel, and it must be
 	// filled with a valid function entry that matches the dummy entry we've
 	// appended to the pclntab.
-- 
2.48.1
