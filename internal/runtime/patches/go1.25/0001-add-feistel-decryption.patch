From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: garble <garble@garble.io>
Date: Sun, 6 Oct 2025 11:20:00 +0000
Subject: [PATCH] runtime: add Feistel decryption table support for metadata
 obfuscation

Phase 2: Lazy decryption table approach
- Add Feistel decryption functions to runtime
- Read decryption table generated by linker
- Populate lookup maps during init()
- Modify entry() to use map lookup (zero crypto in hot path)
---
 src/runtime/symtab.go | 120 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 120 insertions(+)

diff --git a/src/runtime/symtab.go b/src/runtime/symtab.go
index 1234567890..abcdef1234 100644
--- a/src/runtime/symtab.go
+++ b/src/runtime/symtab.go
@@ -5,6 +5,10 @@
 package runtime
 
 import (
+	"encoding/binary"
+	"hash/fnv"
+	_ "unsafe" // for go:linkname
+	
 	"internal/abi"
 	"internal/goarch"
 	"internal/runtime/atomic"
@@ -12,6 +16,122 @@ import (
 	"unsafe"
 )
 
+// Garble: Feistel cipher for runtime metadata decryption (Phase 2)
+// This code is injected by garble to support lazy decryption of encrypted metadata.
+
+// Global decryption maps: encrypted offset â†’ original offset
+// Populated once during init(), used for O(1) lookup in hot path
+var (
+	garbleFeistelLookupTable     map[uint32]uint32
+	garbleFeistelNameLookupTable map[uint32]uint32
+)
+
+// feistelRound applies a single Feistel round using FNV-1a hash as F-function
+func garbleFeistelRound(right uint32, key []byte) uint32 {
+	h := fnv.New32a()
+	var buf [4]byte
+	binary.LittleEndian.PutUint32(buf[:], right)
+	h.Write(buf[:])
+	h.Write(key)
+	return h.Sum32()
+}
+
+// feistelDecrypt32Pair decrypts two uint32 values using 4-round Feistel network
+// Decryption is the reverse of encryption (iterate rounds in reverse order)
+func garbleFeistelDecrypt32Pair(left, right uint32, keys [4][]byte) (uint32, uint32) {
+	// Decrypt: iterate rounds in reverse order (3, 2, 1, 0)
+	for i := 3; i >= 0; i-- {
+		newRight := left
+		newLeft := right ^ garbleFeistelRound(left, keys[i])
+		left = newLeft
+		right = newRight
+	}
+	return left, right
+}
+
+// deriveFeistelKeys derives 4 round keys from a base seed using FNV-1a
+func garbleDeriveFeistelKeys(baseSeed []byte) [4][]byte {
+	var keys [4][]byte
+	for i := 0; i < 4; i++ {
+		h := fnv.New32a()
+		h.Write(baseSeed)
+		h.Write([]byte("round_"))
+		h.Write([]byte{byte('0' + i)})
+		keys[i] = h.Sum(nil)
+	}
+	return keys
+}
+
+// garbleFeistelDecryptTable is the linker-generated symbol containing the decryption table
+// This is created by the garble linker patch and embedded in the binary
+//
+//go:linkname garbleFeistelDecryptTable runtime.feistelDecryptTable
+var garbleFeistelDecryptTable []byte
+
+// garbleInitFeistelTable reads the linker-generated decryption table and populates lookup maps
+// Called once during runtime initialization
+func garbleInitFeistelTable() {
+	// Check if table exists (only present in reversible mode with garble)
+	if len(garbleFeistelDecryptTable) < 40 {
+		// No table or too small - not built with garble reversible mode
+		return
+	}
+	
+	// Parse table header
+	// [0:32]   - Feistel seed (32 bytes SHA-256)
+	// [32:36]  - Entry count (uint32)
+	// [36:40]  - Flags (uint32): bit 0 = reversible
+	// [40:...]  - Entries: [encEntryOff(4)|origEntryOff(4)|encNameOff(4)|origNameOff(4)]
+	
+	seed := garbleFeistelDecryptTable[0:32]
+	entryCount := binary.LittleEndian.Uint32(garbleFeistelDecryptTable[32:36])
+	flags := binary.LittleEndian.Uint32(garbleFeistelDecryptTable[36:40])
+	
+	reversible := (flags & 0x01) != 0
+	if !reversible {
+		// Irreversible mode - no decryption possible
+		return
+	}
+	
+	// Check table size is correct
+	expectedSize := 40 + int(entryCount)*16
+	if len(garbleFeistelDecryptTable) < expectedSize {
+		// Table corrupted or incomplete
+		println("garble: warning: decryption table corrupted")
+		return
+	}
+	
+	// Derive Feistel keys from seed
+	// Note: We don't actually need to decrypt here since the linker
+	// already stored both encrypted and original values in the table!
+	// This is an optimization - we just build the lookup map directly.
+	_ = seed // Keep for future if we want to verify integrity
+	
+	// Initialize maps
+	garbleFeistelLookupTable = make(map[uint32]uint32, entryCount)
+	garbleFeistelNameLookupTable = make(map[uint32]uint32, entryCount)
+	
+	// Read all entries from table
+	offset := 40
+	for i := uint32(0); i < entryCount; i++ {
+		encEntryOff := binary.LittleEndian.Uint32(garbleFeistelDecryptTable[offset:])
+		origEntryOff := binary.LittleEndian.Uint32(garbleFeistelDecryptTable[offset+4:])
+		encNameOff := binary.LittleEndian.Uint32(garbleFeistelDecryptTable[offset+8:])
+		origNameOff := binary.LittleEndian.Uint32(garbleFeistelDecryptTable[offset+12:])
+		
+		// Populate lookup maps
+		garbleFeistelLookupTable[encEntryOff] = origEntryOff
+		garbleFeistelNameLookupTable[encNameOff] = origNameOff
+		
+		offset += 16
+	}
+}
+
+func init() {
+	// Initialize Feistel decryption table if present
+	garbleInitFeistelTable()
+}
+
+// End of Garble Feistel code
+
 // moduledata is the data layout for executable images.
 //
 // The struct is defined in the linker, and there are two copies:
@@ -876,6 +996,14 @@ func pcvalue(f funcInfo, off uint32, targetpc uintptr, strict bool) (int32, ui
 // Do not remove or change the type signature.
 // See go.dev/issue/67401.
 func (f funcInfo) entry() uintptr {
+	// Garble: decrypt entryOff if encryption is active
+	entryOff := f.entryOff
+	if garbleFeistelLookupTable != nil {
+		if decrypted, ok := garbleFeistelLookupTable[entryOff]; ok {
+			entryOff = decrypted
+		}
+	}
+	return f.datap.textAddr(entryOff)
+}
+
+func (f funcInfo) entryOriginal() uintptr {
 	return f.datap.textAddr(f.entryOff)
 }
-- 
2.48.1
